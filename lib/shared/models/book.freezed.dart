// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'book.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Book _$BookFromJson(Map<String, dynamic> json) {
  return _Book.fromJson(json);
}

/// @nodoc
mixin _$Book {
  String get id => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get author => throw _privateConstructorUsedError;
  String get coverUrl => throw _privateConstructorUsedError;
  String get isbn => throw _privateConstructorUsedError;
  int get pageCount => throw _privateConstructorUsedError;
  String get publishedDate => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  List<String> get genres => throw _privateConstructorUsedError;
  double get averageRating => throw _privateConstructorUsedError;
  String get publisher => throw _privateConstructorUsedError;
  String get language => throw _privateConstructorUsedError;
  int get ratingCount => throw _privateConstructorUsedError;

  /// Serializes this Book to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BookCopyWith<Book> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookCopyWith<$Res> {
  factory $BookCopyWith(Book value, $Res Function(Book) then) =
      _$BookCopyWithImpl<$Res, Book>;
  @useResult
  $Res call(
      {String id,
      String title,
      String author,
      String coverUrl,
      String isbn,
      int pageCount,
      String publishedDate,
      String description,
      List<String> genres,
      double averageRating,
      String publisher,
      String language,
      int ratingCount});
}

/// @nodoc
class _$BookCopyWithImpl<$Res, $Val extends Book>
    implements $BookCopyWith<$Res> {
  _$BookCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? author = null,
    Object? coverUrl = null,
    Object? isbn = null,
    Object? pageCount = null,
    Object? publishedDate = null,
    Object? description = null,
    Object? genres = null,
    Object? averageRating = null,
    Object? publisher = null,
    Object? language = null,
    Object? ratingCount = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      author: null == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String,
      coverUrl: null == coverUrl
          ? _value.coverUrl
          : coverUrl // ignore: cast_nullable_to_non_nullable
              as String,
      isbn: null == isbn
          ? _value.isbn
          : isbn // ignore: cast_nullable_to_non_nullable
              as String,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      publishedDate: null == publishedDate
          ? _value.publishedDate
          : publishedDate // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      genres: null == genres
          ? _value.genres
          : genres // ignore: cast_nullable_to_non_nullable
              as List<String>,
      averageRating: null == averageRating
          ? _value.averageRating
          : averageRating // ignore: cast_nullable_to_non_nullable
              as double,
      publisher: null == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as String,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String,
      ratingCount: null == ratingCount
          ? _value.ratingCount
          : ratingCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookImplCopyWith<$Res> implements $BookCopyWith<$Res> {
  factory _$$BookImplCopyWith(
          _$BookImpl value, $Res Function(_$BookImpl) then) =
      __$$BookImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String title,
      String author,
      String coverUrl,
      String isbn,
      int pageCount,
      String publishedDate,
      String description,
      List<String> genres,
      double averageRating,
      String publisher,
      String language,
      int ratingCount});
}

/// @nodoc
class __$$BookImplCopyWithImpl<$Res>
    extends _$BookCopyWithImpl<$Res, _$BookImpl>
    implements _$$BookImplCopyWith<$Res> {
  __$$BookImplCopyWithImpl(_$BookImpl _value, $Res Function(_$BookImpl) _then)
      : super(_value, _then);

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? author = null,
    Object? coverUrl = null,
    Object? isbn = null,
    Object? pageCount = null,
    Object? publishedDate = null,
    Object? description = null,
    Object? genres = null,
    Object? averageRating = null,
    Object? publisher = null,
    Object? language = null,
    Object? ratingCount = null,
  }) {
    return _then(_$BookImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      author: null == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String,
      coverUrl: null == coverUrl
          ? _value.coverUrl
          : coverUrl // ignore: cast_nullable_to_non_nullable
              as String,
      isbn: null == isbn
          ? _value.isbn
          : isbn // ignore: cast_nullable_to_non_nullable
              as String,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      publishedDate: null == publishedDate
          ? _value.publishedDate
          : publishedDate // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      genres: null == genres
          ? _value._genres
          : genres // ignore: cast_nullable_to_non_nullable
              as List<String>,
      averageRating: null == averageRating
          ? _value.averageRating
          : averageRating // ignore: cast_nullable_to_non_nullable
              as double,
      publisher: null == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as String,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String,
      ratingCount: null == ratingCount
          ? _value.ratingCount
          : ratingCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BookImpl implements _Book {
  const _$BookImpl(
      {required this.id,
      required this.title,
      required this.author,
      required this.coverUrl,
      required this.isbn,
      required this.pageCount,
      required this.publishedDate,
      required this.description,
      required final List<String> genres,
      required this.averageRating,
      required this.publisher,
      required this.language,
      required this.ratingCount})
      : _genres = genres;

  factory _$BookImpl.fromJson(Map<String, dynamic> json) =>
      _$$BookImplFromJson(json);

  @override
  final String id;
  @override
  final String title;
  @override
  final String author;
  @override
  final String coverUrl;
  @override
  final String isbn;
  @override
  final int pageCount;
  @override
  final String publishedDate;
  @override
  final String description;
  final List<String> _genres;
  @override
  List<String> get genres {
    if (_genres is EqualUnmodifiableListView) return _genres;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_genres);
  }

  @override
  final double averageRating;
  @override
  final String publisher;
  @override
  final String language;
  @override
  final int ratingCount;

  @override
  String toString() {
    return 'Book(id: $id, title: $title, author: $author, coverUrl: $coverUrl, isbn: $isbn, pageCount: $pageCount, publishedDate: $publishedDate, description: $description, genres: $genres, averageRating: $averageRating, publisher: $publisher, language: $language, ratingCount: $ratingCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.author, author) || other.author == author) &&
            (identical(other.coverUrl, coverUrl) ||
                other.coverUrl == coverUrl) &&
            (identical(other.isbn, isbn) || other.isbn == isbn) &&
            (identical(other.pageCount, pageCount) ||
                other.pageCount == pageCount) &&
            (identical(other.publishedDate, publishedDate) ||
                other.publishedDate == publishedDate) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._genres, _genres) &&
            (identical(other.averageRating, averageRating) ||
                other.averageRating == averageRating) &&
            (identical(other.publisher, publisher) ||
                other.publisher == publisher) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.ratingCount, ratingCount) ||
                other.ratingCount == ratingCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      author,
      coverUrl,
      isbn,
      pageCount,
      publishedDate,
      description,
      const DeepCollectionEquality().hash(_genres),
      averageRating,
      publisher,
      language,
      ratingCount);

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookImplCopyWith<_$BookImpl> get copyWith =>
      __$$BookImplCopyWithImpl<_$BookImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BookImplToJson(
      this,
    );
  }
}

abstract class _Book implements Book {
  const factory _Book(
      {required final String id,
      required final String title,
      required final String author,
      required final String coverUrl,
      required final String isbn,
      required final int pageCount,
      required final String publishedDate,
      required final String description,
      required final List<String> genres,
      required final double averageRating,
      required final String publisher,
      required final String language,
      required final int ratingCount}) = _$BookImpl;

  factory _Book.fromJson(Map<String, dynamic> json) = _$BookImpl.fromJson;

  @override
  String get id;
  @override
  String get title;
  @override
  String get author;
  @override
  String get coverUrl;
  @override
  String get isbn;
  @override
  int get pageCount;
  @override
  String get publishedDate;
  @override
  String get description;
  @override
  List<String> get genres;
  @override
  double get averageRating;
  @override
  String get publisher;
  @override
  String get language;
  @override
  int get ratingCount;

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookImplCopyWith<_$BookImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UserBook _$UserBookFromJson(Map<String, dynamic> json) {
  return _UserBook.fromJson(json);
}

/// @nodoc
mixin _$UserBook {
  Book get book => throw _privateConstructorUsedError;
  BookStatus get status => throw _privateConstructorUsedError;
  int get rating => throw _privateConstructorUsedError;
  String get review => throw _privateConstructorUsedError;
  int get currentPage => throw _privateConstructorUsedError;
  DateTime? get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt => throw _privateConstructorUsedError;

  /// Serializes this UserBook to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserBookCopyWith<UserBook> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserBookCopyWith<$Res> {
  factory $UserBookCopyWith(UserBook value, $Res Function(UserBook) then) =
      _$UserBookCopyWithImpl<$Res, UserBook>;
  @useResult
  $Res call(
      {Book book,
      BookStatus status,
      int rating,
      String review,
      int currentPage,
      DateTime? createdAt,
      DateTime? updatedAt});

  $BookCopyWith<$Res> get book;
  $BookStatusCopyWith<$Res> get status;
}

/// @nodoc
class _$UserBookCopyWithImpl<$Res, $Val extends UserBook>
    implements $UserBookCopyWith<$Res> {
  _$UserBookCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? book = null,
    Object? status = null,
    Object? rating = null,
    Object? review = null,
    Object? currentPage = null,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      book: null == book
          ? _value.book
          : book // ignore: cast_nullable_to_non_nullable
              as Book,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BookStatus,
      rating: null == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as int,
      review: null == review
          ? _value.review
          : review // ignore: cast_nullable_to_non_nullable
              as String,
      currentPage: null == currentPage
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BookCopyWith<$Res> get book {
    return $BookCopyWith<$Res>(_value.book, (value) {
      return _then(_value.copyWith(book: value) as $Val);
    });
  }

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BookStatusCopyWith<$Res> get status {
    return $BookStatusCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$UserBookImplCopyWith<$Res>
    implements $UserBookCopyWith<$Res> {
  factory _$$UserBookImplCopyWith(
          _$UserBookImpl value, $Res Function(_$UserBookImpl) then) =
      __$$UserBookImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Book book,
      BookStatus status,
      int rating,
      String review,
      int currentPage,
      DateTime? createdAt,
      DateTime? updatedAt});

  @override
  $BookCopyWith<$Res> get book;
  @override
  $BookStatusCopyWith<$Res> get status;
}

/// @nodoc
class __$$UserBookImplCopyWithImpl<$Res>
    extends _$UserBookCopyWithImpl<$Res, _$UserBookImpl>
    implements _$$UserBookImplCopyWith<$Res> {
  __$$UserBookImplCopyWithImpl(
      _$UserBookImpl _value, $Res Function(_$UserBookImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? book = null,
    Object? status = null,
    Object? rating = null,
    Object? review = null,
    Object? currentPage = null,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_$UserBookImpl(
      book: null == book
          ? _value.book
          : book // ignore: cast_nullable_to_non_nullable
              as Book,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BookStatus,
      rating: null == rating
          ? _value.rating
          : rating // ignore: cast_nullable_to_non_nullable
              as int,
      review: null == review
          ? _value.review
          : review // ignore: cast_nullable_to_non_nullable
              as String,
      currentPage: null == currentPage
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserBookImpl implements _UserBook {
  const _$UserBookImpl(
      {required this.book,
      required this.status,
      this.rating = 0,
      this.review = '',
      this.currentPage = 0,
      this.createdAt,
      this.updatedAt});

  factory _$UserBookImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserBookImplFromJson(json);

  @override
  final Book book;
  @override
  final BookStatus status;
  @override
  @JsonKey()
  final int rating;
  @override
  @JsonKey()
  final String review;
  @override
  @JsonKey()
  final int currentPage;
  @override
  final DateTime? createdAt;
  @override
  final DateTime? updatedAt;

  @override
  String toString() {
    return 'UserBook(book: $book, status: $status, rating: $rating, review: $review, currentPage: $currentPage, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserBookImpl &&
            (identical(other.book, book) || other.book == book) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.rating, rating) || other.rating == rating) &&
            (identical(other.review, review) || other.review == review) &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, book, status, rating, review,
      currentPage, createdAt, updatedAt);

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserBookImplCopyWith<_$UserBookImpl> get copyWith =>
      __$$UserBookImplCopyWithImpl<_$UserBookImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserBookImplToJson(
      this,
    );
  }
}

abstract class _UserBook implements UserBook {
  const factory _UserBook(
      {required final Book book,
      required final BookStatus status,
      final int rating,
      final String review,
      final int currentPage,
      final DateTime? createdAt,
      final DateTime? updatedAt}) = _$UserBookImpl;

  factory _UserBook.fromJson(Map<String, dynamic> json) =
      _$UserBookImpl.fromJson;

  @override
  Book get book;
  @override
  BookStatus get status;
  @override
  int get rating;
  @override
  String get review;
  @override
  int get currentPage;
  @override
  DateTime? get createdAt;
  @override
  DateTime? get updatedAt;

  /// Create a copy of UserBook
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserBookImplCopyWith<_$UserBookImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BookStatus _$BookStatusFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'wantToRead':
      return _WantToRead.fromJson(json);
    case 'reading':
      return _Reading.fromJson(json);
    case 'completed':
      return _Completed.fromJson(json);
    case 'dnf':
      return _Dnf.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'BookStatus',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$BookStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() wantToRead,
    required TResult Function() reading,
    required TResult Function() completed,
    required TResult Function() dnf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? wantToRead,
    TResult? Function()? reading,
    TResult? Function()? completed,
    TResult? Function()? dnf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? wantToRead,
    TResult Function()? reading,
    TResult Function()? completed,
    TResult Function()? dnf,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WantToRead value) wantToRead,
    required TResult Function(_Reading value) reading,
    required TResult Function(_Completed value) completed,
    required TResult Function(_Dnf value) dnf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WantToRead value)? wantToRead,
    TResult? Function(_Reading value)? reading,
    TResult? Function(_Completed value)? completed,
    TResult? Function(_Dnf value)? dnf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WantToRead value)? wantToRead,
    TResult Function(_Reading value)? reading,
    TResult Function(_Completed value)? completed,
    TResult Function(_Dnf value)? dnf,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this BookStatus to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookStatusCopyWith<$Res> {
  factory $BookStatusCopyWith(
          BookStatus value, $Res Function(BookStatus) then) =
      _$BookStatusCopyWithImpl<$Res, BookStatus>;
}

/// @nodoc
class _$BookStatusCopyWithImpl<$Res, $Val extends BookStatus>
    implements $BookStatusCopyWith<$Res> {
  _$BookStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BookStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$WantToReadImplCopyWith<$Res> {
  factory _$$WantToReadImplCopyWith(
          _$WantToReadImpl value, $Res Function(_$WantToReadImpl) then) =
      __$$WantToReadImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WantToReadImplCopyWithImpl<$Res>
    extends _$BookStatusCopyWithImpl<$Res, _$WantToReadImpl>
    implements _$$WantToReadImplCopyWith<$Res> {
  __$$WantToReadImplCopyWithImpl(
      _$WantToReadImpl _value, $Res Function(_$WantToReadImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$WantToReadImpl implements _WantToRead {
  const _$WantToReadImpl({final String? $type}) : $type = $type ?? 'wantToRead';

  factory _$WantToReadImpl.fromJson(Map<String, dynamic> json) =>
      _$$WantToReadImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'BookStatus.wantToRead()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WantToReadImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() wantToRead,
    required TResult Function() reading,
    required TResult Function() completed,
    required TResult Function() dnf,
  }) {
    return wantToRead();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? wantToRead,
    TResult? Function()? reading,
    TResult? Function()? completed,
    TResult? Function()? dnf,
  }) {
    return wantToRead?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? wantToRead,
    TResult Function()? reading,
    TResult Function()? completed,
    TResult Function()? dnf,
    required TResult orElse(),
  }) {
    if (wantToRead != null) {
      return wantToRead();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WantToRead value) wantToRead,
    required TResult Function(_Reading value) reading,
    required TResult Function(_Completed value) completed,
    required TResult Function(_Dnf value) dnf,
  }) {
    return wantToRead(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WantToRead value)? wantToRead,
    TResult? Function(_Reading value)? reading,
    TResult? Function(_Completed value)? completed,
    TResult? Function(_Dnf value)? dnf,
  }) {
    return wantToRead?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WantToRead value)? wantToRead,
    TResult Function(_Reading value)? reading,
    TResult Function(_Completed value)? completed,
    TResult Function(_Dnf value)? dnf,
    required TResult orElse(),
  }) {
    if (wantToRead != null) {
      return wantToRead(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$WantToReadImplToJson(
      this,
    );
  }
}

abstract class _WantToRead implements BookStatus {
  const factory _WantToRead() = _$WantToReadImpl;

  factory _WantToRead.fromJson(Map<String, dynamic> json) =
      _$WantToReadImpl.fromJson;
}

/// @nodoc
abstract class _$$ReadingImplCopyWith<$Res> {
  factory _$$ReadingImplCopyWith(
          _$ReadingImpl value, $Res Function(_$ReadingImpl) then) =
      __$$ReadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ReadingImplCopyWithImpl<$Res>
    extends _$BookStatusCopyWithImpl<$Res, _$ReadingImpl>
    implements _$$ReadingImplCopyWith<$Res> {
  __$$ReadingImplCopyWithImpl(
      _$ReadingImpl _value, $Res Function(_$ReadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$ReadingImpl implements _Reading {
  const _$ReadingImpl({final String? $type}) : $type = $type ?? 'reading';

  factory _$ReadingImpl.fromJson(Map<String, dynamic> json) =>
      _$$ReadingImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'BookStatus.reading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ReadingImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() wantToRead,
    required TResult Function() reading,
    required TResult Function() completed,
    required TResult Function() dnf,
  }) {
    return reading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? wantToRead,
    TResult? Function()? reading,
    TResult? Function()? completed,
    TResult? Function()? dnf,
  }) {
    return reading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? wantToRead,
    TResult Function()? reading,
    TResult Function()? completed,
    TResult Function()? dnf,
    required TResult orElse(),
  }) {
    if (reading != null) {
      return reading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WantToRead value) wantToRead,
    required TResult Function(_Reading value) reading,
    required TResult Function(_Completed value) completed,
    required TResult Function(_Dnf value) dnf,
  }) {
    return reading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WantToRead value)? wantToRead,
    TResult? Function(_Reading value)? reading,
    TResult? Function(_Completed value)? completed,
    TResult? Function(_Dnf value)? dnf,
  }) {
    return reading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WantToRead value)? wantToRead,
    TResult Function(_Reading value)? reading,
    TResult Function(_Completed value)? completed,
    TResult Function(_Dnf value)? dnf,
    required TResult orElse(),
  }) {
    if (reading != null) {
      return reading(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ReadingImplToJson(
      this,
    );
  }
}

abstract class _Reading implements BookStatus {
  const factory _Reading() = _$ReadingImpl;

  factory _Reading.fromJson(Map<String, dynamic> json) = _$ReadingImpl.fromJson;
}

/// @nodoc
abstract class _$$CompletedImplCopyWith<$Res> {
  factory _$$CompletedImplCopyWith(
          _$CompletedImpl value, $Res Function(_$CompletedImpl) then) =
      __$$CompletedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CompletedImplCopyWithImpl<$Res>
    extends _$BookStatusCopyWithImpl<$Res, _$CompletedImpl>
    implements _$$CompletedImplCopyWith<$Res> {
  __$$CompletedImplCopyWithImpl(
      _$CompletedImpl _value, $Res Function(_$CompletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$CompletedImpl implements _Completed {
  const _$CompletedImpl({final String? $type}) : $type = $type ?? 'completed';

  factory _$CompletedImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompletedImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'BookStatus.completed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CompletedImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() wantToRead,
    required TResult Function() reading,
    required TResult Function() completed,
    required TResult Function() dnf,
  }) {
    return completed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? wantToRead,
    TResult? Function()? reading,
    TResult? Function()? completed,
    TResult? Function()? dnf,
  }) {
    return completed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? wantToRead,
    TResult Function()? reading,
    TResult Function()? completed,
    TResult Function()? dnf,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WantToRead value) wantToRead,
    required TResult Function(_Reading value) reading,
    required TResult Function(_Completed value) completed,
    required TResult Function(_Dnf value) dnf,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WantToRead value)? wantToRead,
    TResult? Function(_Reading value)? reading,
    TResult? Function(_Completed value)? completed,
    TResult? Function(_Dnf value)? dnf,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WantToRead value)? wantToRead,
    TResult Function(_Reading value)? reading,
    TResult Function(_Completed value)? completed,
    TResult Function(_Dnf value)? dnf,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompletedImplToJson(
      this,
    );
  }
}

abstract class _Completed implements BookStatus {
  const factory _Completed() = _$CompletedImpl;

  factory _Completed.fromJson(Map<String, dynamic> json) =
      _$CompletedImpl.fromJson;
}

/// @nodoc
abstract class _$$DnfImplCopyWith<$Res> {
  factory _$$DnfImplCopyWith(_$DnfImpl value, $Res Function(_$DnfImpl) then) =
      __$$DnfImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DnfImplCopyWithImpl<$Res>
    extends _$BookStatusCopyWithImpl<$Res, _$DnfImpl>
    implements _$$DnfImplCopyWith<$Res> {
  __$$DnfImplCopyWithImpl(_$DnfImpl _value, $Res Function(_$DnfImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookStatus
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$DnfImpl implements _Dnf {
  const _$DnfImpl({final String? $type}) : $type = $type ?? 'dnf';

  factory _$DnfImpl.fromJson(Map<String, dynamic> json) =>
      _$$DnfImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'BookStatus.dnf()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DnfImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() wantToRead,
    required TResult Function() reading,
    required TResult Function() completed,
    required TResult Function() dnf,
  }) {
    return dnf();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? wantToRead,
    TResult? Function()? reading,
    TResult? Function()? completed,
    TResult? Function()? dnf,
  }) {
    return dnf?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? wantToRead,
    TResult Function()? reading,
    TResult Function()? completed,
    TResult Function()? dnf,
    required TResult orElse(),
  }) {
    if (dnf != null) {
      return dnf();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WantToRead value) wantToRead,
    required TResult Function(_Reading value) reading,
    required TResult Function(_Completed value) completed,
    required TResult Function(_Dnf value) dnf,
  }) {
    return dnf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WantToRead value)? wantToRead,
    TResult? Function(_Reading value)? reading,
    TResult? Function(_Completed value)? completed,
    TResult? Function(_Dnf value)? dnf,
  }) {
    return dnf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WantToRead value)? wantToRead,
    TResult Function(_Reading value)? reading,
    TResult Function(_Completed value)? completed,
    TResult Function(_Dnf value)? dnf,
    required TResult orElse(),
  }) {
    if (dnf != null) {
      return dnf(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DnfImplToJson(
      this,
    );
  }
}

abstract class _Dnf implements BookStatus {
  const factory _Dnf() = _$DnfImpl;

  factory _Dnf.fromJson(Map<String, dynamic> json) = _$DnfImpl.fromJson;
}
